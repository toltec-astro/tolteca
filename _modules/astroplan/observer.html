
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>astroplan.observer &#8212; tolteca v0.1.dev84+gfc9946a.d20200423</title>
    <link rel="stylesheet" href="../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">TolTECA</span><span id="logotext2"></span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">tolteca v0.1.dev84+gfc9946a.d20200423</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astroplan.observer</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>

<span class="c1"># Standard library</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># Third-party</span>
<span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="p">(</span><span class="n">EarthLocation</span><span class="p">,</span> <span class="n">SkyCoord</span><span class="p">,</span> <span class="n">AltAz</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">,</span>
                                 <span class="n">get_moon</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">Time</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="c1"># Package</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">TargetNeverUpWarning</span><span class="p">,</span> <span class="n">TargetAlwaysUpWarning</span>
<span class="kn">from</span> <span class="nn">.moon</span> <span class="kn">import</span> <span class="n">moon_illumination</span><span class="p">,</span> <span class="n">moon_phase_angle</span>
<span class="kn">from</span> <span class="nn">.target</span> <span class="kn">import</span> <span class="n">get_skycoord</span><span class="p">,</span> <span class="n">SunFlag</span><span class="p">,</span> <span class="n">MoonFlag</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Observer&quot;</span><span class="p">]</span>

<span class="n">MAGIC_TIME</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;jd&#39;</span><span class="p">)</span>


<span class="c1"># Handle deprecated MAGIC_TIME variable</span>
<span class="k">def</span> <span class="nf">deprecation_wrap_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a wrapped object that warns about deprecated accesses&quot;&quot;&quot;</span>
    <span class="n">deprecated</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">DeprecateWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">deprecated</span><span class="p">:</span>
                <span class="n">warnmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;`MAGIC_TIME` will be deprecated in future versions &quot;</span>
                           <span class="s2">&quot;of astroplan. Use masked Time objects instead.&quot;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warnmsg</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">DeprecateWrapper</span><span class="p">()</span>


<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">deprecation_wrap_module</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">],</span>
                                                <span class="n">deprecated</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MAGIC_TIME&#39;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_generate_24hr_grid</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">for_deriv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a nearly linearly spaced grid of time durations.</span>

<span class="sd">    The midpoints of these grid points will span times from ``t0``+``start``</span>
<span class="sd">    to ``t0``+``end``, including the end points, which is useful when taking</span>
<span class="sd">    numerical derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t0 : `~astropy.time.Time`</span>
<span class="sd">        Time queried for, grid will be built from or up to this time.</span>

<span class="sd">    start : float</span>
<span class="sd">        Number of days before/after ``t0`` to start the grid.</span>

<span class="sd">    end : float</span>
<span class="sd">        Number of days before/after ``t0`` to end the grid.</span>

<span class="sd">    N : int</span>
<span class="sd">        Number of grid points to generate</span>

<span class="sd">    for_deriv : bool</span>
<span class="sd">        Generate time series for taking numerical derivative (modify</span>
<span class="sd">        bounds)?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `~astropy.time.Time`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">for_deriv</span><span class="p">:</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">N</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]])</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">day</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">day</span>

    <span class="c1"># broadcast so grid is first index, and remaining shape of t0</span>
    <span class="c1"># falls in later indices. e.g. if t0 is shape (10), time_grid</span>
    <span class="c1"># will be shape (N, 10). If t0 is shape (5, 2), time_grid is (N, 5, 2)</span>
    <span class="k">while</span> <span class="n">time_grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">time_grid</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># we want to avoid 1D grids since we always want to broadcast against targets</span>
    <span class="k">if</span> <span class="n">time_grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">time_grid</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">time_grid</span>


<span class="k">class</span> <span class="nc">Observer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container class for information about an observer&#39;s location and</span>
<span class="sd">    environment.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We can create an observer at Subaru Observatory in Hawaii two ways. First,</span>
<span class="sd">    locations for some observatories are stored in astroplan, and these can be</span>
<span class="sd">    accessed by name, like so:</span>

<span class="sd">    &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">    &gt;&gt;&gt; subaru = Observer.at_site(&quot;Subaru&quot;, timezone=&quot;US/Hawaii&quot;)</span>

<span class="sd">    To find out which observatories can be accessed by name, check out</span>
<span class="sd">    `~astropy.coordinates.EarthLocation.get_site_names`.</span>

<span class="sd">    Next, you can initialize an observer by specifying the location with</span>
<span class="sd">    `~astropy.coordinates.EarthLocation`:</span>

<span class="sd">    &gt;&gt;&gt; from astropy.coordinates import EarthLocation</span>
<span class="sd">    &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">    &gt;&gt;&gt; location = EarthLocation.from_geodetic(-155.4761*u.deg, 19.825*u.deg,</span>
<span class="sd">    ...                                        4139*u.m)</span>
<span class="sd">    &gt;&gt;&gt; subaru = Observer(location=location, name=&quot;Subaru&quot;, timezone=&quot;US/Hawaii&quot;)</span>

<span class="sd">    You can also create an observer without an</span>
<span class="sd">    `~astropy.coordinates.EarthLocation`:</span>

<span class="sd">    &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">    &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">    &gt;&gt;&gt; subaru = Observer(longitude=-155.4761*u.deg, latitude=19.825*u.deg,</span>
<span class="sd">    ...                   elevation=0*u.m, name=&quot;Subaru&quot;, timezone=&quot;US/Hawaii&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">elevation</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="s1">&#39;UTC&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">latitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">longitude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elevation</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">pressure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_humidity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : `~astropy.coordinates.EarthLocation`</span>
<span class="sd">            The location (latitude, longitude, elevation) of the observatory.</span>

<span class="sd">        timezone : str or `datetime.tzinfo` (optional)</span>
<span class="sd">            The local timezone to assume. If a string, it will be passed</span>
<span class="sd">            through ``pytz.timezone()`` to produce the timezone object.</span>

<span class="sd">        name : str</span>
<span class="sd">            A short name for the telescope, observatory or location.</span>

<span class="sd">        latitude : float, str, `~astropy.units.Quantity` (optional)</span>
<span class="sd">            The latitude of the observing location. Should be valid input for</span>
<span class="sd">            initializing a `~astropy.coordinates.Latitude` object.</span>

<span class="sd">        longitude : float, str, `~astropy.units.Quantity` (optional)</span>
<span class="sd">            The longitude of the observing location. Should be valid input for</span>
<span class="sd">            initializing a `~astropy.coordinates.Longitude` object.</span>

<span class="sd">        elevation : `~astropy.units.Quantity` (optional), default = 0 meters</span>
<span class="sd">            The elevation of the observing location, with respect to sea</span>
<span class="sd">            level. Defaults to sea level.</span>

<span class="sd">        pressure : `~astropy.units.Quantity` (optional)</span>
<span class="sd">            The ambient pressure. Defaults to zero (i.e. no atmosphere).</span>

<span class="sd">        relative_humidity : float (optional)</span>
<span class="sd">            The ambient relative humidity.</span>

<span class="sd">        temperature : `~astropy.units.Quantity` (optional)</span>
<span class="sd">            The ambient temperature.</span>

<span class="sd">        description : str (optional)</span>
<span class="sd">            A short description of the telescope, observatory or observing</span>
<span class="sd">            location.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">=</span> <span class="n">pressure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_humidity</span> <span class="o">=</span> <span class="n">relative_humidity</span>

        <span class="c1"># If lat/long given instead of EarthLocation, convert them</span>
        <span class="c1"># to EarthLocation</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">latitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                                 <span class="n">longitude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">EarthLocation</span><span class="o">.</span><span class="n">from_geodetic</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span>
                                                        <span class="n">elevation</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">EarthLocation</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Observatory location must be specified with &#39;</span>
                            <span class="s1">&#39;either (1) an instance of &#39;</span>
                            <span class="s1">&#39;astropy.coordinates.EarthLocation or (2) &#39;</span>
                            <span class="s1">&#39;latitude and longitude in degrees as &#39;</span>
                            <span class="s1">&#39;accepted by astropy.coordinates.Latitude and &#39;</span>
                            <span class="s1">&#39;astropy.coordinates.Latitude.&#39;</span><span class="p">)</span>

        <span class="c1"># Accept various timezone inputs, default to UTC</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timezone</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timezone</span> <span class="o">=</span> <span class="n">timezone</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timezone</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timezone</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="n">timezone</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;timezone keyword should be a string, or an &#39;</span>
                            <span class="s1">&#39;instance of datetime.tzinfo&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of the `~astroplan.Observer` object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; keck = Observer.at_site(&quot;Keck&quot;, timezone=&quot;US/Hawaii&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(keck)                                    # doctest: +FLOAT_CMP</span>
<span class="sd">        &lt;Observer: name=&#39;Keck&#39;,</span>
<span class="sd">            location (lon, lat, el)=(-155.478333333 deg, 19.8283333333 deg, 4160.0 m),</span>
<span class="sd">            timezone=&lt;DstTzInfo &#39;US/Hawaii&#39; LMT-1 day, 13:29:00 STD&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">attr_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;timezone&#39;</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">,</span> <span class="s1">&#39;temperature&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;relative_humidity&#39;</span><span class="p">]</span>
        <span class="n">attr_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">]</span>
        <span class="n">attributes_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr_names</span><span class="p">,</span> <span class="n">attr_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Format location for easy readability</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;location&#39;</span><span class="p">:</span>
                    <span class="n">formatted_loc</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">to_geodetic</span><span class="p">()]</span>
                    <span class="n">attributes_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (lon, lat, el)=(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formatted_loc</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">attributes_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attributes_strings</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">at_site</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">site_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an `~astroplan.observer.Observer` object with a site name.</span>

<span class="sd">        Extra keyword arguments are passed to the `~astroplan.Observer`</span>
<span class="sd">        constructor (see `~astroplan.Observer` for available keyword</span>
<span class="sd">        arguments).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        site_name : str</span>
<span class="sd">            Observatory name, must be resolvable with</span>
<span class="sd">            `~astropy.coordinates.EarthLocation.get_site_names`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astroplan.observer.Observer`</span>
<span class="sd">            Observer object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialize an observer at Kitt Peak National Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; kpno_generic = Observer.at_site(&#39;kpno&#39;)</span>
<span class="sd">        &gt;&gt;&gt; kpno_today = Observer.at_site(&#39;kpno&#39;, pressure=1*u.bar, temperature=0*u.deg_C)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">site_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;location&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location kwarg should not be used if &quot;</span>
                             <span class="s2">&quot;initializing an Observer with Observer.at_site()&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">EarthLocation</span><span class="o">.</span><span class="n">of_site</span><span class="p">(</span><span class="n">site_name</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astropy_time_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">astropy_time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the `~astropy.time.Time` object ``astropy_time`` to a</span>
<span class="sd">        localized `~datetime.datetime` object.</span>

<span class="sd">        Timezones localized with `pytz`_.</span>

<span class="sd">        .. _pytz: https://pypi.python.org/pypi/pytz/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        astropy_time : `~astropy.time.Time`</span>
<span class="sd">            Scalar or list-like.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~datetime.datetime`</span>
<span class="sd">            Localized datetime, where the timezone of the datetime is</span>
<span class="sd">            set by the ``timezone`` keyword argument of the</span>
<span class="sd">            `~astroplan.Observer` constructor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert an astropy time to a localized `~datetime.datetime`:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; subaru = Observer.at_site(&quot;Subaru&quot;, timezone=&quot;US/Hawaii&quot;)</span>
<span class="sd">        &gt;&gt;&gt; astropy_time = Time(&#39;1999-12-31 06:00:00&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(subaru.astropy_time_to_datetime(astropy_time))</span>
<span class="sd">        1999-12-30 20:00:00-10:00</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">astropy_time</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">astropy_time_to_datetime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">astropy_time</span><span class="p">]</span>

        <span class="c1"># Convert astropy.time.Time to a UTC localized datetime (aware)</span>
        <span class="n">utc_datetime</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">astropy_time</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>

        <span class="c1"># Convert UTC to local timezone</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">utc_datetime</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">datetime_to_astropy_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date_time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the `~datetime.datetime` object ``date_time`` to a</span>
<span class="sd">        `~astropy.time.Time` object.</span>

<span class="sd">        Timezones localized with `pytz`_. If the ``date_time`` is naive, the</span>
<span class="sd">        implied timezone is the ``timezone`` structure of ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        date_time : `~datetime.datetime` or list-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Astropy time object (no timezone information preserved).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert a localized `~datetime.datetime` to a `~astropy.time.Time`</span>
<span class="sd">        object. Non-localized datetimes are assumed to be UTC.</span>
<span class="sd">        &lt;Time object: scale=&#39;utc&#39; format=&#39;datetime&#39; value=1999-12-31 06:00:00&gt;</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; import datetime</span>
<span class="sd">        &gt;&gt;&gt; import pytz</span>
<span class="sd">        &gt;&gt;&gt; subaru = Observer.at_site(&quot;Subaru&quot;, timezone=&quot;US/Hawaii&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hi_date_time = datetime.datetime(2005, 6, 21, 20, 0, 0, 0)</span>
<span class="sd">        &gt;&gt;&gt; subaru.datetime_to_astropy_time(hi_date_time)</span>
<span class="sd">        &lt;Time object: scale=&#39;utc&#39; format=&#39;datetime&#39; value=2005-06-22 06:00:00&gt;</span>
<span class="sd">        &gt;&gt;&gt; utc_date_time = datetime.datetime(2005, 6, 22, 6, 0, 0, 0,</span>
<span class="sd">        ...                                   tzinfo=pytz.timezone(&quot;UTC&quot;))</span>
<span class="sd">        &gt;&gt;&gt; subaru.datetime_to_astropy_time(utc_date_time)</span>
<span class="sd">        &lt;Time object: scale=&#39;utc&#39; format=&#39;datetime&#39; value=2005-06-22 06:00:00&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">date_time</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Time</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_astropy_time</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">date_time</span><span class="p">])</span>

        <span class="c1"># For timezone-naive datetimes, assign local timezone</span>
        <span class="k">if</span> <span class="n">date_time</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">date_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">date_time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Time</span><span class="p">(</span><span class="n">date_time</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_broadcastable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shp1</span><span class="p">,</span> <span class="n">shp2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if two shape tuples are broadcastable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shp1</span> <span class="o">==</span> <span class="n">shp2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shp1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shp2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_preprocess_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess time and target inputs</span>

<span class="sd">        This routine takes the inputs for time and target and attempts to</span>
<span class="sd">        return a single `~astropy.time.Time` and `~astropy.coordinates.SkyCoord`</span>
<span class="sd">        for each argument, which may be non-scalar if necessary.</span>

<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            The time(s) to use in the calculation. It can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astroplan.FixedTarget`, `~astropy.coordinates.SkyCoord`, or list</span>
<span class="sd">            The target(s) to use in the calculation.</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto</span>
<span class="sd">            the end, so that calculations with M targets and N times will</span>
<span class="sd">            return an (M, N) shaped result. Otherwise, we rely on broadcasting</span>
<span class="sd">            the shapes together using standard numpy rules. Useful for grid</span>
<span class="sd">            searches for rise/set times etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure we have a non-scalar time</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># convert any kind of target argument to non-scalar SkyCoord</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">get_skycoord</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grid_times_targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="c1"># ensure we have a (1, 1) shape coord</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">target</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_broadcastable</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time and Target arguments cannot be broadcast &#39;</span>
                             <span class="s1">&#39;against each other with shapes </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">altaz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obswl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an `~astropy.coordinates.AltAz` frame or coordinate.</span>

<span class="sd">        If ``target`` is None, generates an altitude/azimuth frame. Otherwise,</span>
<span class="sd">        calculates the transformation to that frame for the requested ``target``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            The time at which the observation is taking place. Will be used as</span>
<span class="sd">            the ``obstime`` attribute in the resulting frame or coordinate. This</span>
<span class="sd">            will be passed in as the first argument to the `~astropy.time.Time`</span>
<span class="sd">            initializer, so it can be anything that `~astropy.time.Time` will</span>
<span class="sd">            accept (including a `~astropy.time.Time` object)</span>

<span class="sd">        target : `~astroplan.FixedTarget`, `~astropy.coordinates.SkyCoord`, or list (optional)</span>
<span class="sd">            Celestial object(s) of interest. If ``target`` is `None`, returns</span>
<span class="sd">            the `~astropy.coordinates.AltAz` frame without coordinates.</span>

<span class="sd">        obswl : `~astropy.units.Quantity` (optional)</span>
<span class="sd">            Wavelength of the observation used in the calculation.</span>

<span class="sd">        grid_times_targets: bool (optional)</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy</span>
<span class="sd">            rules. Useful for grid searches for rise/set times etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.AltAz`</span>
<span class="sd">            If ``target`` is `None`, returns `~astropy.coordinates.AltAz`</span>
<span class="sd">            frame. If ``target`` is not `None`, returns the ``target``</span>
<span class="sd">            transformed to the `~astropy.coordinates.AltAz` frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create an instance of the `~astropy.coordinates.AltAz` frame for an</span>
<span class="sd">        observer at Apache Point Observatory at a particular time:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&#39;2001-02-03 04:05:06&#39;)</span>
<span class="sd">        &gt;&gt;&gt; target = SkyCoord(0*u.deg, 0*u.deg)</span>
<span class="sd">        &gt;&gt;&gt; altaz_frame = apo.altaz(time)</span>

<span class="sd">        Now transform the target&#39;s coordinates to the alt/az frame:</span>

<span class="sd">        &gt;&gt;&gt; target_altaz = target.transform_to(altaz_frame) # doctest: +SKIP</span>

<span class="sd">        Alternatively, construct an alt/az frame and transform the target to</span>
<span class="sd">        that frame all in one step:</span>

<span class="sd">        &gt;&gt;&gt; target_altaz = apo.altaz(time, target) # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_inputs</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="p">)</span>

        <span class="n">altaz_frame</span> <span class="o">=</span> <span class="n">AltAz</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">obstime</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                            <span class="n">pressure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="p">,</span> <span class="n">obswl</span><span class="o">=</span><span class="n">obswl</span><span class="p">,</span>
                            <span class="n">temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
                            <span class="n">relative_humidity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_humidity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Return just the frame</span>
            <span class="k">return</span> <span class="n">altaz_frame</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">transform_to</span><span class="p">(</span><span class="n">altaz_frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parallactic_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the parallactic angle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time`</span>
<span class="sd">            Observation time.</span>

<span class="sd">        target : `~astroplan.FixedTarget` or `~astropy.coordinates.SkyCoord` or list</span>
<span class="sd">            Target celestial object(s).</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto</span>
<span class="sd">            the end, so that calculations with M targets and N times will</span>
<span class="sd">            return an (M, N) shaped result. Otherwise, we rely on broadcasting</span>
<span class="sd">            the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.Angle`</span>
<span class="sd">            Parallactic angle.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The parallactic angle is the angle between the great circle that</span>
<span class="sd">        intersects a celestial object and the zenith, and the object&#39;s hour</span>
<span class="sd">        circle [1]_.</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Parallactic_angle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">coordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_inputs</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="p">)</span>

        <span class="c1"># Eqn (14.1) of Meeus&#39; Astronomical Algorithms</span>
        <span class="n">LST</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">sidereal_time</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">longitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">LST</span> <span class="o">-</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">H</span><span class="p">),</span>
                       <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">coordinate</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">coordinate</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">rad</span>

        <span class="k">return</span> <span class="n">Angle</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># Sun-related methods.</span>
    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_horiz_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">rise_set</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find time ``t`` when values in array ``a`` go from</span>
<span class="sd">        negative to positive or positive to negative (exclude endpoints)</span>

<span class="sd">        ``return_limits`` will return nearest times to zero-crossing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : `~astropy.time.Time`</span>
<span class="sd">            Grid of N times, any shape. Search grid along first axis, e.g (N, ...)</span>
<span class="sd">        alt : `~astropy.units.Quantity`</span>
<span class="sd">            Grid of altitudes</span>
<span class="sd">            Depending on broadcasting we either have ndim &gt;=3 and</span>
<span class="sd">            M targets along first axis, e.g (M, N, ...), or</span>
<span class="sd">            ndim = 2 and targets/times in last axis</span>
<span class="sd">        rise_set : {&quot;rising&quot;,  &quot;setting&quot;}</span>
<span class="sd">            Calculate either rising or setting across the horizon</span>
<span class="sd">        horizon : float</span>
<span class="sd">            Number of degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Returns the lower and upper limits on the time and altitudes</span>
<span class="sd">        of the horizon crossing. The altitude limits have shape (M, ...) and the</span>
<span class="sd">        time limits have shape (...). These arrays aresuitable for interpolation</span>
<span class="sd">        to find the horizon crossing time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># handle different cases by enforcing standard shapes on</span>
        <span class="c1"># the altitude grid</span>
        <span class="n">finesse_time_indexes</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must supply more at least a 2D grid of altitudes&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># TODO: this test for ndim=2 doesn&#39;t work. if times is e.g (2,5)</span>
            <span class="c1"># then alt will have ndim=3, but shape (100, 2, 5) so grid</span>
            <span class="c1"># is in first index...</span>
            <span class="n">ntargets</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ngrid</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">alt</span><span class="p">,</span> <span class="p">(</span><span class="n">ntargets</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">ntargets</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="o">*</span><span class="n">unit</span>
            <span class="n">extra_dimension_added</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finesse_time_indexes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extra_dimension_added</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">alt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">alt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">rise_set</span> <span class="o">==</span> <span class="s1">&#39;rising&#39;</span><span class="p">:</span>
            <span class="c1"># Find index where altitude goes from below to above horizon</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="p">((</span><span class="n">alt</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">horizon</span><span class="p">)</span> <span class="o">*</span>
                         <span class="p">(</span><span class="n">alt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">horizon</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">rise_set</span> <span class="o">==</span> <span class="s1">&#39;setting&#39;</span><span class="p">:</span>
            <span class="c1"># Find index where altitude goes from above to below horizon</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="p">((</span><span class="n">alt</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">horizon</span><span class="p">)</span> <span class="o">*</span>
                         <span class="p">(</span><span class="n">alt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">horizon</span><span class="p">))</span>

        <span class="n">noncrossing_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="n">alt_lims1</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_shape</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
        <span class="n">alt_lims2</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_shape</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
        <span class="n">jd_lims1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="n">jd_lims2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">target_index</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">warnmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Target with index </span><span class="si">{}</span><span class="s1"> does not cross horizon=</span><span class="si">{}</span><span class="s1"> &#39;</span>
                           <span class="s1">&#39;within 24 hours&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_index</span><span class="p">,</span> <span class="n">horizon</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">alt</span><span class="p">[</span><span class="n">target_index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">horizon</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warnmsg</span><span class="p">,</span> <span class="n">TargetAlwaysUpWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warnmsg</span><span class="p">,</span> <span class="n">TargetNeverUpWarning</span><span class="p">)</span>

            <span class="n">alt_lims1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">alt_lims2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">jd_lims1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">jd_lims2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">noncrossing_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">before_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
        <span class="c1"># we want to add an vector like (0, 1, ...) to get after indices</span>
        <span class="n">after_indices</span> <span class="o">=</span> <span class="n">before_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">after_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">al1</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">before_indices</span><span class="p">)]</span>
        <span class="n">al2</span> <span class="o">=</span> <span class="n">alt</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">after_indices</span><span class="p">)]</span>
        <span class="c1"># slice the time in the same way, but delete the object index</span>
        <span class="n">before_time_index_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">before_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">after_time_index_tuple</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">after_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finesse_time_indexes</span><span class="p">:</span>
            <span class="n">before_time_index_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">after_time_index_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tl1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">before_time_index_tuple</span><span class="p">)]</span>
        <span class="n">tl2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">after_time_index_tuple</span><span class="p">)]</span>

        <span class="n">alt_lims1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">before_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="n">al1</span>
        <span class="n">alt_lims2</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">before_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="n">al2</span>
        <span class="n">jd_lims1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">before_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="n">tl1</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">jd</span>
        <span class="n">jd_lims2</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">before_indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="n">tl2</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">jd</span>

        <span class="k">if</span> <span class="n">extra_dimension_added</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">alt_lims1</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="n">alt_lims2</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(),</span>
                    <span class="n">jd_lims1</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="n">jd_lims2</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alt_lims1</span><span class="p">,</span> <span class="n">alt_lims2</span><span class="p">,</span> <span class="n">jd_lims1</span><span class="p">,</span> <span class="n">jd_lims2</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_two_point_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jd_before</span><span class="p">,</span> <span class="n">jd_after</span><span class="p">,</span>
                          <span class="n">alt_before</span><span class="p">,</span> <span class="n">alt_after</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do linear interpolation between two ``altitudes`` at</span>
<span class="sd">        two ``times`` to determine the time where the altitude</span>
<span class="sd">        goes through zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        jd_before : `float`</span>
<span class="sd">            JD(UTC) before crossing event</span>

<span class="sd">        jd_after : `float`</span>
<span class="sd">            JD(UTC) after crossing event</span>

<span class="sd">        alt_before : `~astropy.units.Quantity`</span>
<span class="sd">            altitude before crossing event</span>

<span class="sd">        alt_after : `~astropy.units.Quantity`</span>
<span class="sd">            altitude after crossing event</span>

<span class="sd">        horizon : `~astropy.units.Quantity`</span>
<span class="sd">            Solve for the time when the altitude is equal to</span>
<span class="sd">            reference_alt.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : `~astropy.time.Time`</span>
<span class="sd">            Time when target crosses the horizon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Approximate the horizon-crossing time:</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">alt_after</span><span class="o">-</span><span class="n">alt_before</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">jd_after</span> <span class="o">-</span> <span class="n">jd_before</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="n">crossing_jd</span> <span class="o">=</span> <span class="p">(</span><span class="n">jd_after</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">d</span> <span class="o">-</span> <span class="p">((</span><span class="n">alt_after</span> <span class="o">-</span> <span class="n">horizon</span><span class="p">)</span> <span class="o">/</span> <span class="n">slope</span><span class="p">))</span>

        <span class="c1"># TODO: edit after https://github.com/astropy/astropy/issues/9612 has</span>
        <span class="c1"># been addressed.</span>

        <span class="c1"># Determine whether or not there are NaNs in the crossing_jd array which</span>
        <span class="c1"># represent computations where no horizon crossing was found:</span>
        <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">crossing_jd</span><span class="p">)</span>
        <span class="c1"># If there are, set them equal to zero, rather than np.nan</span>
        <span class="n">crossing_jd</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">crossing_jd</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;jd&#39;</span><span class="p">)</span>
        <span class="c1"># Create a Time object with masked out times where there were NaNs</span>
        <span class="n">times</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_altitude_trig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LST</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the altitude of ``target`` at local sidereal times ``LST``.</span>

<span class="sd">        This method provides a factor of ~3 speed up over calling `altaz`, and</span>
<span class="sd">        inherently does *not* take the atmosphere into account.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        LST : `~astropy.time.Time`</span>
<span class="sd">            Local sidereal times (array)</span>

<span class="sd">        target : {`~astropy.coordinates.SkyCoord`, `FixedTarget`} or similar</span>
<span class="sd">            Target celestial object&#39;s coordinates.</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto</span>
<span class="sd">            the end, so that calculations with M targets and N times will</span>
<span class="sd">            return an (M, N) shaped result. Otherwise, we rely on broadcasting</span>
<span class="sd">            the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alt : `~astropy.unit.Quantity`</span>
<span class="sd">            Array of altitudes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LST</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_inputs</span><span class="p">(</span><span class="n">LST</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dec</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">radian</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dec</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">LST</span><span class="o">.</span><span class="n">radian</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">radian</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">alt</span>

    <span class="k">def</span> <span class="nf">_calc_riseset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">prev_next</span><span class="p">,</span> <span class="n">rise_set</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                      <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at next rise/set of ``target``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Position of target or multiple positions of that target</span>
<span class="sd">            at multiple times (if target moves, like the Sun)</span>

<span class="sd">        prev_next : str - either &#39;previous&#39; or &#39;next&#39;</span>
<span class="sd">            Test next rise/set or previous rise/set</span>

<span class="sd">        rise_set : str - either &#39;rising&#39; or &#39;setting&#39;</span>
<span class="sd">            Compute prev/next rise or prev/next set</span>

<span class="sd">        horizon : `~astropy.units.Quantity`</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        N : int</span>
<span class="sd">            Number of altitudes to compute when searching for</span>
<span class="sd">            rise or set.</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto</span>
<span class="sd">            the end, so that calculations with M targets and N times will</span>
<span class="sd">            return an (M, N) shaped result. Otherwise, we rely on broadcasting</span>
<span class="sd">            the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ret1 : `~astropy.time.Time`</span>
<span class="sd">            Time of rise/set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prev_next</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">approx_sidereal_drift</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;approx_sidereal_drift&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">approx_sidereal_drift</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                           <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;approx_sidereal_drift&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">_generate_24hr_grid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="n">MoonFlag</span><span class="p">:</span>
            <span class="n">altaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">get_moon</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">),</span>
                               <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">target</span> <span class="ow">is</span> <span class="n">SunFlag</span><span class="p">:</span>
            <span class="n">altaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">times</span><span class="p">),</span>
                               <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">altaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                               <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">)</span>

        <span class="n">altitudes</span> <span class="o">=</span> <span class="n">altaz</span><span class="o">.</span><span class="n">alt</span>

        <span class="n">al1</span><span class="p">,</span> <span class="n">al2</span><span class="p">,</span> <span class="n">jd1</span><span class="p">,</span> <span class="n">jd2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_horiz_cross</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">altitudes</span><span class="p">,</span> <span class="n">rise_set</span><span class="p">,</span>
                                               <span class="n">horizon</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_two_point_interp</span><span class="p">(</span><span class="n">jd1</span><span class="p">,</span> <span class="n">jd2</span><span class="p">,</span> <span class="n">al1</span><span class="p">,</span> <span class="n">al2</span><span class="p">,</span>
                                      <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_transit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">prev_next</span><span class="p">,</span> <span class="n">antitransit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at next transit of the meridian of `target`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Position of target or multiple positions of that target</span>
<span class="sd">            at multiple times (if target moves, like the Sun)</span>

<span class="sd">        prev_next : str - either &#39;previous&#39; or &#39;next&#39;</span>
<span class="sd">            Test next rise/set or previous rise/set</span>

<span class="sd">        antitransit : bool</span>
<span class="sd">            Toggle compute antitransit (below horizon, equivalent to midnight</span>
<span class="sd">            for the Sun)</span>

<span class="sd">        N : int</span>
<span class="sd">            Number of altitudes to compute when searching for</span>
<span class="sd">            rise or set.</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto</span>
<span class="sd">            the end, so that calculations with M targets and N times will</span>
<span class="sd">            return an (M, N) shaped result. Otherwise, we rely on broadcasting</span>
<span class="sd">            the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ret1 : `~astropy.time.Time`</span>
<span class="sd">            Time of transit/antitransit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO FIX BROADCASTING HERE</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prev_next</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">_generate_24hr_grid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="p">,</span>
                                        <span class="n">for_deriv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">_generate_24hr_grid</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="p">,</span>
                                        <span class="n">for_deriv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># The derivative of the altitude with respect to time is increasing</span>
        <span class="c1"># from negative to positive values at the anti-transit of the meridian</span>
        <span class="k">if</span> <span class="n">antitransit</span><span class="p">:</span>
            <span class="n">rise_set</span> <span class="o">=</span> <span class="s1">&#39;rising&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rise_set</span> <span class="o">=</span> <span class="s1">&#39;setting&#39;</span>

        <span class="n">altaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="n">altitudes</span> <span class="o">=</span> <span class="n">altaz</span><span class="o">.</span><span class="n">alt</span>
        <span class="k">if</span> <span class="n">altitudes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># shape is (M, N, ...) where M is targets and N is grid</span>
            <span class="n">d_altitudes</span> <span class="o">=</span> <span class="n">altitudes</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># shape is (N, M) where M is targets and N is grid</span>
            <span class="n">d_altitudes</span> <span class="o">=</span> <span class="n">altitudes</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">Time</span><span class="p">((</span><span class="n">times</span><span class="o">.</span><span class="n">jd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">times</span><span class="o">.</span><span class="n">jd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;jd&#39;</span><span class="p">)</span>

        <span class="n">horizon</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span>  <span class="c1"># Find when derivative passes through zero</span>
        <span class="n">al1</span><span class="p">,</span> <span class="n">al2</span><span class="p">,</span> <span class="n">jd1</span><span class="p">,</span> <span class="n">jd2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_horiz_cross</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">d_altitudes</span><span class="p">,</span>
                                               <span class="n">rise_set</span><span class="p">,</span> <span class="n">horizon</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_two_point_interp</span><span class="p">(</span><span class="n">jd1</span><span class="p">,</span> <span class="n">jd2</span><span class="p">,</span> <span class="n">al1</span><span class="p">,</span> <span class="n">al2</span><span class="p">,</span>
                                      <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_determine_which_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">args_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run through the next/previous/nearest permutations of the solutions</span>
<span class="sd">        to `function(time, ...)`, and return the previous/next/nearest one</span>
<span class="sd">        specified by the args stored in args_dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">which</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;which&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;horizon&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">rise_set</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rise_set&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">antitransit</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;antitransit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">grid_times_targets</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid_times_targets&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">n_grid_points</span> <span class="o">=</span> <span class="n">args_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_grid_points&#39;</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>

        <span class="c1"># Assemble arguments for function, depending on the function.</span>
        <span class="k">if</span> <span class="n">function</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_riseset</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">event_function</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">rise_set</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">,</span>
                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">function</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_transit</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">event_function</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">antitransit</span><span class="o">=</span><span class="n">antitransit</span><span class="p">,</span>
                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">,</span>
                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Function </span><span class="si">{}</span><span class="s1"> not supported in &#39;</span>
                             <span class="s1">&#39;_determine_which_event.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span> <span class="ow">or</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">next_event</span> <span class="o">=</span> <span class="n">event_function</span><span class="p">(</span><span class="s1">&#39;next&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">next_event</span>

        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;previous&#39;</span> <span class="ow">or</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">previous_event</span> <span class="o">=</span> <span class="n">event_function</span><span class="p">(</span><span class="s1">&#39;previous&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;previous&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">previous_event</span>

        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">previous_event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">next_event</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Time</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">previous_event</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">jd</span><span class="p">,</span>
                                 <span class="n">next_event</span><span class="o">.</span><span class="n">utc</span><span class="o">.</span><span class="n">jd</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;jd&#39;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;which&quot; kwarg must be &quot;next&quot;, &quot;previous&quot; or &#39;</span>
                         <span class="s1">&#39;&quot;nearest&quot;.&#39;</span><span class="p">)</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">target_rise_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                         <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate rise time.</span>

<span class="sd">        Compute time of the next/previous/nearest rise of the ``target``</span>
<span class="sd">        object, where &quot;rise&quot; is defined as the time when the ``target``</span>
<span class="sd">        transitions from altitudes below the ``horizon`` to above the</span>
<span class="sd">        ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunrise relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy rules.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields rise time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Rise time of target</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the rise time of Rigel at Keck Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer, FixedTarget</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2001-02-03 04:05:06&quot;)</span>
<span class="sd">        &gt;&gt;&gt; target = FixedTarget.from_name(&quot;Rigel&quot;)</span>
<span class="sd">        &gt;&gt;&gt; keck = Observer.at_site(&quot;Keck&quot;)</span>
<span class="sd">        &gt;&gt;&gt; rigel_rise_time = keck.target_rise_time(time, target, which=&quot;next&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(rigel_rise_time)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-04 00:51:23.330, JD: 2451944.53569</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_which_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calc_riseset</span><span class="p">,</span>
                                           <span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">rise_set</span><span class="o">=</span><span class="s1">&#39;rising&#39;</span><span class="p">,</span>
                                                <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">,</span>
                                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">,</span>
                                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">))</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">target_set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                        <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate set time.</span>

<span class="sd">        Compute time of the next/previous/nearest set of ``target``, where</span>
<span class="sd">        &quot;set&quot; is defined as when the ``target`` transitions from altitudes</span>
<span class="sd">        above ``horizon`` to below ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunset relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy rules.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields set time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Set time of target.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the set time of Rigel at Keck Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer, FixedTarget</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2001-02-03 04:05:06&quot;)</span>
<span class="sd">        &gt;&gt;&gt; target = FixedTarget.from_name(&quot;Rigel&quot;)</span>
<span class="sd">        &gt;&gt;&gt; keck = Observer.at_site(&quot;Keck&quot;)</span>
<span class="sd">        &gt;&gt;&gt; rigel_set_time = keck.target_set_time(time, target, which=&quot;next&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(rigel_set_time)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-03 12:29:34.768, JD: 2451944.02054</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_which_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calc_riseset</span><span class="p">,</span>
                                           <span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span>
                                                <span class="n">rise_set</span><span class="o">=</span><span class="s1">&#39;setting&#39;</span><span class="p">,</span>
                                                <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">,</span>
                                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">,</span>
                                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">target_meridian_transit_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                     <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate time at the transit of the meridian.</span>

<span class="sd">        Compute time of the next/previous/nearest transit of the ``target``</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunrise relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy rules.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields rise time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Transit time of target</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the meridian transit time of Rigel at Keck Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer, FixedTarget</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2001-02-03 04:05:06&quot;)</span>
<span class="sd">        &gt;&gt;&gt; target = FixedTarget.from_name(&quot;Rigel&quot;)</span>
<span class="sd">        &gt;&gt;&gt; keck = Observer.at_site(&quot;Keck&quot;)</span>
<span class="sd">        &gt;&gt;&gt; rigel_transit_time = keck.target_meridian_transit_time(time, target,</span>
<span class="sd">        ...                                                        which=&quot;next&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(rigel_transit_time)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-03 06:42:26.863, JD: 2451943.77948</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_which_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calc_transit</span><span class="p">,</span>
                                           <span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span>
                                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">,</span>
                                                <span class="n">rise_set</span><span class="o">=</span><span class="s1">&#39;setting&#39;</span><span class="p">,</span>
                                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">target_meridian_antitransit_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                         <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate time at the antitransit of the meridian.</span>

<span class="sd">        Compute time of the next/previous/nearest antitransit of the ``target``</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunrise relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        grid_times_targets : bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed onto the end,</span>
<span class="sd">            so that calculations with M targets and N times will return an (M, N)</span>
<span class="sd">            shaped result. Otherwise, we rely on broadcasting the shapes together</span>
<span class="sd">            using standard numpy rules.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields rise time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Antitransit time of target</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the meridian anti-transit time of Rigel at Keck Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer, FixedTarget</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2001-02-03 04:05:06&quot;)</span>
<span class="sd">        &gt;&gt;&gt; target = FixedTarget.from_name(&quot;Rigel&quot;)</span>
<span class="sd">        &gt;&gt;&gt; keck = Observer.at_site(&quot;Keck&quot;)</span>
<span class="sd">        &gt;&gt;&gt; rigel_antitransit_time = keck.target_meridian_antitransit_time(</span>
<span class="sd">        ...     time, target, which=&quot;next&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(rigel_antitransit_time)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-03 18:40:29.761, JD: 2451944.27812</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_which_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calc_transit</span><span class="p">,</span>
                                           <span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">antitransit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">rise_set</span><span class="o">=</span><span class="s1">&#39;setting&#39;</span><span class="p">,</span>
                                                <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">,</span>
                                                <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">))</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sun_rise_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time of sunrise.</span>

<span class="sd">        Compute time of the next/previous/nearest sunrise, where</span>
<span class="sd">        sunrise is defined as when the Sun transitions from altitudes</span>
<span class="sd">        below ``horizon`` to above ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunrise relative to the present ``time`` would you</span>
<span class="sd">            like to calculate.</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields rise time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of sunrise</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the time of the previous sunrise at Apache Point Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&#39;2001-02-03 04:05:06&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sun_rise = apo.sun_rise_time(time, which=&quot;previous&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(sun_rise)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-02 14:02:50.554, JD: 2451943.08531</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_rise_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                                     <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sun_set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time of sunset.</span>

<span class="sd">        Compute time of the next/previous/nearest sunset, where</span>
<span class="sd">        sunset is defined as when the Sun transitions from altitudes</span>
<span class="sd">        below ``horizon`` to above ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which sunset relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields set time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of sunset</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the time of the next sunset at Apache Point Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&#39;2001-02-03 04:05:06&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sun_set = apo.sun_set_time(time, which=&quot;next&quot;) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;ISO: {0.iso}, JD: {0.jd}&quot;.format(sun_set)) # doctest: +SKIP</span>
<span class="sd">        ISO: 2001-02-04 00:35:42.102, JD: 2451944.52479</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_set_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                                    <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">noon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at solar noon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which noon relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields noon time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time at solar noon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_meridian_transit_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">which</span><span class="p">,</span>
                                                 <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">midnight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at solar midnight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which noon relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields midnight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time at solar midnight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_meridian_antitransit_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">which</span><span class="p">,</span>
                                                     <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="c1"># Twilight convenience functions</span>

    <span class="k">def</span> <span class="nf">twilight_evening_astronomical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at evening astronomical (-18 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate. Default is nearest.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of twilight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_set_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">18</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                 <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twilight_evening_nautical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at evening nautical (-12 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate. Default is nearest.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of twilight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_set_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">12</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                 <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twilight_evening_civil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at evening civil (-6 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate. Default is nearest.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of twilight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_set_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">6</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                 <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twilight_morning_astronomical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at morning astronomical (-18 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of twilight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_rise_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">18</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                  <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twilight_morning_nautical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at morning nautical (-12 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate. Default is nearest.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of twilight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_rise_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">12</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                  <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">twilight_morning_civil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time at morning civil (-6 degree) twilight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which twilight relative to the present ``time`` would you</span>
<span class="sd">            like to calculate. Default is nearest.</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields twilight time precisions better than one minute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.time.Time`</span>
<span class="sd">            Time of sunset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_rise_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=-</span><span class="mi">6</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                  <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="c1"># Moon-related methods.</span>

    <span class="k">def</span> <span class="nf">moon_rise_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local moon rise time.</span>

<span class="sd">        Compute time of the next/previous/nearest moon rise, where</span>
<span class="sd">        moon rise is defined as the time when the moon transitions from</span>
<span class="sd">        altitudes below ``horizon`` to above ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which moon rise relative to the present ``time`` would you</span>
<span class="sd">            like to calculate.</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields rise time precisions better than one minute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_rise_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">MoonFlag</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                                     <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moon_set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">n_grid_points</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local moon set time.</span>

<span class="sd">        Compute time of the next/previous/nearest moon set, where</span>
<span class="sd">        moon set is defined as the time when the moon transitions from</span>
<span class="sd">        altitudes below ``horizon`` to above ``horizon``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        which : {&#39;next&#39;, &#39;previous&#39;, &#39;nearest&#39;}</span>
<span class="sd">            Choose which moon set relative to the present ``time`` would you</span>
<span class="sd">            like to calculate.</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating set/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        N : int</span>
<span class="sd">            The number of grid points on which to search for the horizon</span>
<span class="sd">            crossings of the target over a 24 hour period, default is 150 which</span>
<span class="sd">            yields set time precisions better than one minute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_set_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">MoonFlag</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">horizon</span><span class="p">,</span>
                                    <span class="n">n_grid_points</span><span class="o">=</span><span class="n">n_grid_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moon_illumination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the illuminated fraction of the moon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Fraction of lunar surface illuminated</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        How much of the lunar surface is illuminated at 2015-08-29 18:35 UTC,</span>
<span class="sd">        which we happen to know is the time of a full moon?</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2015-08-29 18:35&quot;)</span>
<span class="sd">        &gt;&gt;&gt; apo.moon_illumination(time) # doctest: +SKIP</span>
<span class="sd">        array([ 0.99972487])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moon_illumination</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moon_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate lunar orbital phase.</span>

<span class="sd">        For example, phase=pi is &quot;new&quot;, phase=0 is &quot;full&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moon_phase_angle : float</span>
<span class="sd">            Orbital phase angle of the moon where pi corresponds to new moon,</span>
<span class="sd">            zero corresponds to full moon.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the phase of the moon at 2015-08-29 18:35 UTC. Near zero</span>
<span class="sd">        radians corresponds to a nearly full moon.</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&#39;APO&#39;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&#39;2015-08-29 18:35&#39;)</span>
<span class="sd">        &gt;&gt;&gt; apo.moon_phase(time) # doctest: +SKIP</span>
<span class="sd">        &lt;Quantity [ 0.03317537] rad&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moon_phase_angle</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moon_altaz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">ephemeris</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the position of the moon in alt/az.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object).</span>

<span class="sd">        ephemeris : str, optional</span>
<span class="sd">            Ephemeris to use.  If not given, use the one set with</span>
<span class="sd">            ``astropy.coordinates.solar_system_ephemeris.set`` (which is</span>
<span class="sd">            set to &#39;builtin&#39; by default).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        altaz : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Position of the moon transformed to altitude and azimuth</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the altitude and azimuth of the moon at Apache Point</span>
<span class="sd">        Observatory:</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2015-08-29 18:35&quot;)</span>
<span class="sd">        &gt;&gt;&gt; altaz_moon = apo.moon_altaz(time) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;alt: {0.alt}, az: {0.az}&quot;.format(altaz_moon)) # doctest: +SKIP</span>
<span class="sd">        alt: -63.72706397691421 deg, az: 345.3640380598265 deg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">moon</span> <span class="o">=</span> <span class="n">get_moon</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">ephemeris</span><span class="o">=</span><span class="n">ephemeris</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">moon</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sun_altaz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the position of the Sun in alt/az.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            This will be passed in as the first argument to</span>
<span class="sd">            the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object).</span>

<span class="sd">        ephemeris : str, optional</span>
<span class="sd">            Ephemeris to use.  If not given, use the one set with</span>
<span class="sd">            ``astropy.coordinates.solar_system_ephemeris.set`` (which is</span>
<span class="sd">            set to &#39;builtin&#39; by default).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        altaz : `~astropy.coordinates.SkyCoord`</span>
<span class="sd">            Position of the sun transformed to altitude and azimuth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">sun</span> <span class="o">=</span> <span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">sun</span><span class="p">)</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">target_is_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                     <span class="n">return_altaz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is ``target`` above ``horizon`` at this ``time``?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating rise/set times (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        return_altaz : bool (optional)</span>
<span class="sd">            Also return the &#39;~astropy.coordinates.AltAz&#39; coordinate.</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        observable : boolean or np.ndarray(bool)</span>
<span class="sd">            True if ``target`` is above ``horizon`` at ``time``, else False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Are Aldebaran and Vega above the horizon at Apache Point Observatory</span>
<span class="sd">        at 2015-08-29 18:35 UTC?</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer, FixedTarget</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2015-08-29 18:35&quot;)</span>
<span class="sd">        &gt;&gt;&gt; aldebaran = FixedTarget.from_name(&quot;Aldebaran&quot;)</span>
<span class="sd">        &gt;&gt;&gt; vega = FixedTarget.from_name(&quot;Vega&quot;)</span>
<span class="sd">        &gt;&gt;&gt; apo.target_is_up(time, aldebaran) # doctest: +SKIP</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; apo.target_is_up(time, [aldebaran, vega]) # doctest: +SKIP</span>
<span class="sd">        array([ True, False], dtype=bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">altaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="n">observable</span> <span class="o">=</span> <span class="n">altaz</span><span class="o">.</span><span class="n">alt</span> <span class="o">&gt;</span> <span class="n">horizon</span>

        <span class="k">if</span> <span class="n">altaz</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="n">observable</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">observable</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_altaz</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">observable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">observable</span><span class="p">,</span> <span class="n">altaz</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_night</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">obswl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the Sun below ``horizon`` at ``time``?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use</span>
<span class="sd">            for calculating day/night (i.e.,</span>
<span class="sd">            -6 deg horizon = civil twilight, etc.)</span>

<span class="sd">        obswl : `~astropy.units.Quantity` (optional)</span>
<span class="sd">            Wavelength of the observation used in the calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sun_below_horizon : bool or np.ndarray(bool)</span>
<span class="sd">            `True` if sun is below ``horizon`` at ``time``, else `False`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Is it &quot;nighttime&quot; (i.e. is the Sun below ``horizon``) at Apache Point</span>
<span class="sd">        Observatory at 2015-08-29 18:35 UTC?</span>

<span class="sd">        &gt;&gt;&gt; from astroplan import Observer</span>
<span class="sd">        &gt;&gt;&gt; from astropy.time import Time</span>
<span class="sd">        &gt;&gt;&gt; apo = Observer.at_site(&quot;APO&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time = Time(&quot;2015-08-29 18:35&quot;)</span>
<span class="sd">        &gt;&gt;&gt; apo.is_night(time) # doctest: +SKIP</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">solar_altitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">altaz</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">get_sun</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">obswl</span><span class="o">=</span><span class="n">obswl</span><span class="p">)</span><span class="o">.</span><span class="n">alt</span>

        <span class="k">if</span> <span class="n">solar_altitude</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">solar_altitude</span> <span class="o">&lt;</span> <span class="n">horizon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">solar_altitude</span> <span class="o">&lt;</span> <span class="n">horizon</span>

    <span class="k">def</span> <span class="nf">local_sidereal_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;apparent&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert ``time`` to local sidereal time for observer.</span>

<span class="sd">        This is a thin wrapper around the `~astropy.time.Time.sidereal_time`</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        kind : {&#39;mean&#39;, &#39;apparent&#39;} (optional)</span>
<span class="sd">            Passed to the ``kind`` argument of</span>
<span class="sd">            `~astropy.time.Time.sidereal_time`</span>

<span class="sd">        model : str or `None`; optional</span>
<span class="sd">            The precession/nutation model to assume - see</span>
<span class="sd">            `~astropy.time.Time.sidereal_time` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.Longitude`</span>
<span class="sd">            Local sidereal time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">sidereal_time</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">longitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span>
                                  <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">target_hour_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the local hour angle of ``target`` at ``time``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` or other (see below)</span>
<span class="sd">            Time of observation. This will be passed in as the first argument</span>
<span class="sd">            to the `~astropy.time.Time` initializer, so it can be anything that</span>
<span class="sd">            `~astropy.time.Time` will accept (including a `~astropy.time.Time`</span>
<span class="sd">            object)</span>

<span class="sd">        target : `~astropy.coordinates.SkyCoord`, `~astroplan.FixedTarget`, or list</span>
<span class="sd">            Target celestial object(s)</span>

<span class="sd">        grid_times_targets: bool</span>
<span class="sd">            If True, the target object will have extra dimensions packed</span>
<span class="sd">            onto the end, so that calculations with M targets and N times</span>
<span class="sd">            will return an (M, N) shaped result. Otherwise, we rely on</span>
<span class="sd">            broadcasting the shapes together using standard numpy rules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hour_angle : `~astropy.coordinates.Angle`</span>
<span class="sd">            The hour angle(s) of the target(s) at ``time``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_inputs</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">grid_times_targets</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Longitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_sidereal_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span>

    <span class="nd">@u</span><span class="o">.</span><span class="n">quantity_input</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">tonight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">obswl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a time range corresponding to the nearest night</span>

<span class="sd">        This will return a range of `~astropy.time.Time` corresponding to the</span>
<span class="sd">        beginning and ending of the night. If in the middle of a given night,</span>
<span class="sd">        return times from `~astropy.time.Time.now` until the nearest</span>
<span class="sd">        `~astroplan.Observer.sun_rise_time`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : `~astropy.time.Time` (optional), default = `~astropy.time.Time.now`</span>
<span class="sd">            The start time for tonight, which is allowed to be arbitrary.</span>
<span class="sd">            See description above for behavior</span>
<span class="sd">        horizon : `~astropy.units.Quantity` (optional), default = zero degrees</span>
<span class="sd">            Degrees above/below actual horizon to use for calculating rise/set</span>
<span class="sd">            times (e.g., -6 deg horizon = civil twilight, etc.)</span>
<span class="sd">        obswl : `~astropy.units.Quantity` (optional)</span>
<span class="sd">            Wavelength of the observation used in the calculation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        times : `~astropy.time.Time`</span>
<span class="sd">            A tuple of times corresponding to the start and end of current night</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">time</span>
        <span class="n">night_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_night</span><span class="p">(</span><span class="n">current_time</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">,</span> <span class="n">obswl</span><span class="o">=</span><span class="n">obswl</span><span class="p">)</span>
        <span class="n">sun_set_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_set_time</span><span class="p">(</span><span class="n">current_time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;next&#39;</span><span class="p">,</span>
                                         <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">)</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">night_mask</span><span class="p">,</span> <span class="n">current_time</span><span class="p">,</span> <span class="n">sun_set_time</span><span class="p">)</span>
        <span class="c1"># np.where gives us a list of start Times - convert to Time object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sun_rise_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;next&#39;</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2020, Zhiyuan Ma.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.0.2. &nbsp;
    Last built 23 Apr 2020. <br/>
  </p>
</footer>
  </body>
</html>